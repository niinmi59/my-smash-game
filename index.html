<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Apex Style FPS - Sound & Battle Loop</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: 'Segoe UI', sans-serif; user-select: none; }
        
        /* UIレイヤー */
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }

        /* HUD: 体力と弾薬 */
        #hud {
            position: absolute; bottom: 40px; left: 40px; right: 40px;
            display: flex; justify-content: space-between; align-items: flex-end;
        }
        .hud-box { color: white; text-shadow: 2px 2px 0 #000; }
        .hp-bar-bg { width: 300px; height: 20px; background: rgba(0,0,0,0.5); border: 2px solid #555; transform: skewX(-20deg); }
        .hp-bar-fill { width: 100%; height: 100%; background: #00ffcc; transition: width 0.2s; }
        .hp-text { font-size: 24px; font-weight: bold; margin-bottom: 5px; display: block; }
        .ammo { font-size: 50px; font-weight: 800; color: #fff; }
        .ammo span { font-size: 24px; color: #aaa; }

        /* クロスヘア */
        #crosshair {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 20px; height: 20px; display: flex; justify-content: center; align-items: center;
        }
        .ch-dot { width: 4px; height: 4px; background: #ff3333; border-radius: 50%; box-shadow: 0 0 4px #ff0000; }
        .ch-circle { position: absolute; width: 100%; height: 100%; border: 2px solid rgba(255, 255, 255, 0.4); border-radius: 50%; }

        /* スタート画面 & リザルト画面 */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 10; pointer-events: auto;
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            color: white; transition: opacity 0.3s;
        }
        h1 { font-size: 60px; margin: 0; letter-spacing: 5px; text-transform: uppercase; color: #00ffcc; text-shadow: 0 0 20px rgba(0,255,204,0.5); }
        .status-msg { font-size: 24px; color: #ccc; margin-top: 10px; }
        
        /* ボタン */
        .btn {
            margin-top: 40px; padding: 15px 40px; font-size: 24px; font-weight: bold;
            color: #fff; background: linear-gradient(45deg, #ff3333, #aa0000);
            border: none; border-radius: 4px; cursor: pointer; transform: skewX(-10deg);
            box-shadow: 0 5px 15px rgba(255,0,0,0.4); transition: transform 0.1s, filter 0.1s;
        }
        .btn:hover { filter: brightness(1.2); transform: skewX(-10deg) scale(1.05); }
        .btn:active { transform: skewX(-10deg) scale(0.95); }
        
        .waiting-text { display: none; margin-top: 20px; color: #00ffcc; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }

    </style>
</head>
<body>
    <div id="ui">
        <div id="crosshair"><div class="ch-circle"></div><div class="ch-dot"></div></div>
        <div id="hud">
            <div class="hud-box">
                <span class="hp-text">HEALTH</span>
                <div class="hp-bar-bg"><div id="hp-bar" class="hp-bar-fill"></div></div>
            </div>
            <div class="hud-box">
                <div class="ammo">30 <span>/ ∞</span></div>
            </div>
        </div>
    </div>

    <div id="overlay">
        <h1 id="title-text">APEX FPS</h1>
        <p class="status-msg" id="sub-text">CLICK TO DEPLOY</p>
        <button id="action-btn" class="btn" style="display:none;">REMATCH</button>
        <p id="waiting-msg" class="waiting-text">WAITING FOR PLAYER 2...</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>

    <script>
        // --- サウンド管理 (Web Audio API) ---
        // 外部ファイルを使わず、ブラウザの機能で音を合成します
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx;

        function initAudio() {
            if (!audioCtx) audioCtx = new AudioContext();
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function playSound(type) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            const now = audioCtx.currentTime;
            
            if (type === 'shoot') {
                // 射撃音: 高速でピッチが下がるノイズ混じりの音
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.15);
            } else if (type === 'hit') {
                // ヒット音: 高い「ピシッ」という音
                osc.type = 'square';
                osc.frequency.setValueAtTime(1500, now);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'win') {
                // 勝利音
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(440, now);
                osc.frequency.linearRampToValueAtTime(880, now + 0.5);
                gain.gain.setValueAtTime(0.5, now);
                gain.gain.linearRampToValueAtTime(0, now + 1.0);
                osc.start(now);
                osc.stop(now + 1.0);
            }
        }

        // --- ゲーム設定 ---
        const PLAYER_SPEED = 12.0;
        const SPRINT_SPEED = 20.0;
        const ENEMY_SPEED = 6.0;
        
        let scene, camera, renderer, controls;
        let moveF = false, moveB = false, moveL = false, moveR = false, isSprint = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let prevTime = performance.now();

        let weaponGroup;
        let recoilTimer = 0;
        let health = 100;
        let isGameOver = false;

        // 敵管理
        let enemies = [];
        let enemyCount = 5;

        // UI要素
        const overlay = document.getElementById('overlay');
        const titleText = document.getElementById('title-text');
        const subText = document.getElementById('sub-text');
        const actionBtn = document.getElementById('action-btn');
        const waitingMsg = document.getElementById('waiting-msg');
        const hpBar = document.getElementById('hp-bar');

        init();
        animate();

        function init() {
            // シーン
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x607080);
            scene.fog = new THREE.FogExp2(0x607080, 0.002);

            // カメラ
            camera = new THREE.PerspectiveCamera(85, window.innerWidth / window.innerHeight, 0.1, 1000);

            // レンダラー
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // ライト
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            scene.add(hemiLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.set(2048, 2048);
            scene.add(dirLight);

            // コントロール
            controls = new THREE.PointerLockControls(camera, document.body);
            
            // 初回クリックイベント
            overlay.addEventListener('click', startGame);
            
            // 再戦ボタンイベント
            actionBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // 親への伝播を止める
                startRematchSequence();
            });

            scene.add(controls.getObject());

            createMap();
            createWeapon();
            resetGameLogic();

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            window.addEventListener('resize', onResize);
        }

        // --- ゲーム進行管理 ---
        function startGame() {
            if (isGameOver) return; // ゲームオーバー時はボタン処理に任せる
            initAudio(); // 音声有効化
            controls.lock();
            overlay.style.opacity = 0;
            overlay.style.pointerEvents = 'none';
        }

        function resetGameLogic() {
            health = 100;
            isGameOver = false;
            updateHP();
            
            // 敵のリセット
            enemies.forEach(e => scene.remove(e.mesh));
            enemies = [];
            for(let i=0; i<enemyCount; i++) spawnEnemy();

            // プレイヤー位置リセット
            if (controls.getObject()) {
                controls.getObject().position.set(0, 1.7, 0);
                velocity.set(0,0,0);
            }
        }

        function startRematchSequence() {
            // 再戦演出
            actionBtn.style.display = 'none';
            waitingMsg.style.display = 'block';
            
            // "マルチで2人が押した"風の演出として少し待つ
            setTimeout(() => {
                waitingMsg.style.display = 'none';
                resetGameLogic();
                // 画面リセット
                overlay.style.opacity = 0;
                overlay.style.pointerEvents = 'none';
                controls.lock();
            }, 1500);
        }

        function endGame(result) {
            isGameOver = true;
            controls.unlock();
            
            overlay.style.opacity = 1;
            overlay.style.pointerEvents = 'auto';
            overlay.removeEventListener('click', startGame); // 画面クリックでの復帰を無効化

            if (result === 'win') {
                titleText.innerText = "CHAMPION";
                titleText.style.color = "#ffd700";
                subText.innerText = "ALL ENEMIES ELIMINATED";
                playSound('win');
            } else {
                titleText.innerText = "ELIMINATED";
                titleText.style.color = "#ff3333";
                subText.innerText = "MISSION FAILED";
            }

            actionBtn.style.display = 'block';
            actionBtn.innerText = "REMATCH";
        }

        // --- マップ・武器・敵 ---
        function createMap() {
            // 床
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(200, 200),
                new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8 })
            );
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // グリッド
            const grid = new THREE.GridHelper(200, 40, 0x000000, 0x000000);
            grid.material.opacity = 0.2;
            grid.material.transparent = true;
            scene.add(grid);

            // 障害物
            const boxGeo = new THREE.BoxGeometry(1, 1, 1);
            const boxMat = new THREE.MeshStandardMaterial({ color: 0x888888 });

            function wall(x, z, w, h, d) {
                const m = new THREE.Mesh(boxGeo, boxMat);
                m.position.set(x, h/2, z);
                m.scale.set(w, h, d);
                m.castShadow = true; m.receiveShadow = true;
                scene.add(m);
            }
            // 壁
            wall(0, -50, 100, 10, 2); wall(0, 50, 100, 10, 2);
            wall(-50, 0, 2, 10, 100); wall(50, 0, 2, 10, 100);
            // 遮蔽物
            wall(-15, -15, 5, 3, 5); wall(20, 10, 8, 4, 2); wall(0, 25, 2, 3, 10);
        }

        function createWeapon() {
            weaponGroup = new THREE.Group();
            camera.add(weaponGroup);
            weaponGroup.position.set(0.25, -0.25, -0.6);

            const dark = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.2 });
            const skin = new THREE.MeshStandardMaterial({ color: 0xffdbac });

            // 銃
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.6), dark);
            weaponGroup.add(body);
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.4), new THREE.MeshStandardMaterial({color:0x666666}));
            barrel.rotation.x = Math.PI/2; barrel.position.set(0, 0.05, -0.4);
            weaponGroup.add(barrel);
            
            // 腕と手
            const arm = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.07, 0.6), skin);
            arm.rotation.x = -Math.PI/4; arm.position.set(0.1, -0.2, 0.3);
            weaponGroup.add(arm);
            const hand = new THREE.Mesh(new THREE.SphereGeometry(0.08), skin);
            hand.position.set(0, -0.1, 0.1);
            weaponGroup.add(hand);
        }

        function spawnEnemy() {
            const grp = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: 0xcc3333 });
            
            // 人型モデル
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.25), new THREE.MeshStandardMaterial({color:0xffffff}));
            head.position.y = 1.7; grp.add(head);
            
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.9, 0.3), mat);
            body.position.y = 1.1; grp.add(body);
            
            const limb = new THREE.BoxGeometry(0.2, 0.8, 0.2);
            const lArm = new THREE.Mesh(limb, mat); lArm.position.set(0.4, 1.3, 0); grp.add(lArm);
            const rArm = new THREE.Mesh(limb, mat); rArm.position.set(-0.4, 1.3, 0); grp.add(rArm);

            // 配置 (プレイヤーから離れた位置)
            let x, z;
            do {
                x = (Math.random() - 0.5) * 80;
                z = (Math.random() - 0.5) * 80;
            } while (Math.abs(x) < 10 && Math.abs(z) < 10);

            grp.position.set(x, 0, z);
            grp.userData = { hp: 3, id: Math.random() };
            grp.traverse(o => { if(o.isMesh) o.castShadow = true; });
            
            scene.add(grp);
            enemies.push({ mesh: grp, speed: ENEMY_SPEED * (0.8 + Math.random()*0.4) });
        }

        // --- 入力処理 ---
        function onKeyDown(e) {
            switch(e.code) {
                case 'KeyW': moveF = true; break;
                case 'KeyS': moveB = true; break;
                case 'KeyA': moveL = true; break;
                case 'KeyD': moveR = true; break;
                case 'ShiftLeft': isSprint = true; break;
            }
        }
        function onKeyUp(e) {
            switch(e.code) {
                case 'KeyW': moveF = false; break;
                case 'KeyS': moveB = false; break;
                case 'KeyA': moveL = false; break;
                case 'KeyD': moveR = false; break;
                case 'ShiftLeft': isSprint = false; break;
            }
        }
        function onMouseDown() {
            if (!controls.isLocked || isGameOver) return;
            shoot();
        }

        function shoot() {
            playSound('shoot'); // 発砲音
            recoilTimer = 1.0;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);

            // 敵のメッシュ抽出
            const targets = [];
            enemies.forEach(e => e.mesh.traverse(o => { if(o.isMesh) targets.push(o); }));
            
            const hits = raycaster.intersectObjects(targets);
            if (hits.length > 0) {
                const hitObj = hits[0].object;
                const root = hitObj.parent;
                
                // ダメージ演出
                hitObj.material.emissive.setHex(0xffffff);
                setTimeout(() => { if(hitObj) hitObj.material.emissive.setHex(0x000000); }, 50);
                playSound('hit'); // ヒット音

                if (root && root.userData) {
                    root.userData.hp--;
                    if (root.userData.hp <= 0) {
                        // 敵死亡
                        scene.remove(root);
                        enemies = enemies.filter(e => e.mesh !== root);
                        
                        // 勝利判定
                        if (enemies.length === 0) {
                            endGame('win');
                        }
                    }
                }
            }
        }

        function updateHP() {
            hpBar.style.width = health + '%';
            if (health < 30) hpBar.style.backgroundColor = '#ff3333';
            else hpBar.style.backgroundColor = '#00ffcc';
        }

        // --- ループ処理 ---
        function animate() {
            requestAnimationFrame(animate);
            if (isGameOver) return;

            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            if (controls.isLocked) {
                // 1. プレイヤー移動
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                direction.z = Number(moveF) - Number(moveB);
                direction.x = Number(moveR) - Number(moveL);
                direction.normalize();

                const speed = isSprint ? SPRINT_SPEED : PLAYER_SPEED;
                if (moveF || moveB) velocity.z -= direction.z * speed * delta;
                if (moveL || moveR) velocity.x -= direction.x * speed * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);

                // 2. 敵AI (プレイヤーを追尾)
                const playerPos = camera.position;
                enemies.forEach(enemy => {
                    const e = enemy.mesh;
                    e.lookAt(playerPos.x, 0, playerPos.z);
                    const dist = e.position.distanceTo(playerPos);
                    
                    if (dist > 1.0) {
                        e.translateZ(enemy.speed * delta);
                    } else {
                        // プレイヤーに接触 -> ダメージ
                        health -= 1;
                        updateHP();
                        if (health <= 0) endGame('lose');
                    }
                });

                // 3. 武器のアニメーション
                const moveSpd = velocity.length();
                if (moveSpd > 0.5) {
                    weaponGroup.position.y = -0.25 + Math.sin(time * 0.015) * 0.01;
                    weaponGroup.position.x = 0.25 + Math.cos(time * 0.015) * 0.01;
                }
                
                if (recoilTimer > 0) {
                    recoilTimer -= delta * 5;
                    weaponGroup.position.z = -0.6 + 0.15 * recoilTimer;
                    weaponGroup.rotation.x = 0.1 * recoilTimer;
                } else {
                    weaponGroup.position.z = -0.6;
                    weaponGroup.rotation.x = 0;
                }
            }
            
            renderer.render(scene, camera);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
