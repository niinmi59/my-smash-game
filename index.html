<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Ultimate Smash Online v16</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #111; font-family: 'Segoe UI', sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; color: white; user-select: none; }
        canvas { display: none; width: 100%; height: 100%; background: linear-gradient(to bottom, #87CEEB 0%, #E0F7FA 100%); }
        
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background: rgba(0,0,0,0.95); z-index: 100; }
        h1 { font-size: 40px; text-shadow: 0 0 10px #ff0055; margin-bottom: 20px; font-style: italic; }
        .box { background: #222; padding: 20px; border-radius: 10px; border: 2px solid #555; text-align: center; max-width: 500px; width: 90%; }
        input { padding: 10px; font-size: 18px; width: 70%; text-align: center; margin-bottom: 10px; border-radius: 5px; border: none; }
        button { padding: 10px 30px; font-size: 18px; cursor: pointer; background: #ffe600; border: none; font-weight: bold; margin-top: 10px; border-radius: 50px; transition: 0.2s; }
        button:hover { transform: scale(1.05); box-shadow: 0 0 15px #ffe600; }
        button:disabled { background: #555; color: #888; cursor: default; transform: none; box-shadow: none; }

        .char-select { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; margin-top: 20px; }
        .card { width: 90px; padding: 5px; background: #333; border: 2px solid #555; border-radius: 5px; cursor: pointer; }
        .card.selected { border-color: #ffe600; background: #555; box-shadow: 0 0 10px #ffe600; }
        .icon { width: 40px; height: 40px; border-radius: 50%; margin: 0 auto 5px; border: 3px solid #fff; }
        
        #hud { position: absolute; bottom: 20px; width: 100%; display: none; justify-content: center; gap: 60px; pointer-events: none; }
        .hud-box { text-align: center; background: rgba(0,0,0,0.6); padding: 10px 20px; border-radius: 10px; min-width: 150px; }
        .hud-name { font-size: 14px; font-weight: bold; color: #ccc; margin-bottom: 5px; }
        .pct { font-size: 40px; font-weight: 900; }
        .bar-container { width: 100%; height: 4px; background: #444; margin-top: 4px; display: none; }
        .bar-fill { height: 100%; width: 0%; transition: width 0.1s; }
        .shield-bar { width: 100%; height: 4px; background: #500; margin-top: 4px; }
        .shield-fill { height: 100%; background: #00aaff; width: 100%; }
        .stocks { display: flex; justify-content: center; gap: 4px; margin-top: 5px; }
        .dot { width: 10px; height: 10px; border-radius: 50%; border: 2px solid #fff; }

        #result { display: none; background: rgba(0,0,0,0.85); }
        #win-msg { font-size: 80px; font-weight: 900; font-style: italic; margin-bottom: 30px; text-shadow: 0 0 20px #fff; }
        .rematch-status { display: flex; gap: 20px; margin-bottom: 20px; font-size: 20px; }
        .p-status { color: #555; font-weight: bold; }
        .p-status.ready { color: #0f0; text-shadow: 0 0 10px #0f0; }
    </style>
</head>
<body>

<div id="menu" class="overlay">
    <h1>SMASH ONLINE v16</h1>
    <div id="step0" class="box">
        <h3>プレイヤー名を入力</h3>
        <input type="text" id="username-input" placeholder="名前 (例: プレイヤー1)" maxlength="10">
        <button onclick="setName()">決定</button>
    </div>
    <div id="step1" class="box" style="display:none;">
        <h3 id="welcome-msg"></h3>
        <p>ファイター選択</p>
        <div class="char-select">
            <div class="card" onclick="sel('kou',this)"><div class="icon" style="background:#3399ff"></div>こう</div>
            <div class="card" onclick="sel('minto',this)"><div class="icon" style="background:#00ffcc"></div>みんと</div>
            <div class="card" onclick="sel('kanade',this)"><div class="icon" style="background:#ff0066"></div>かなで</div>
            <div class="card" onclick="sel('shiyou',this)"><div class="icon" style="background:#8888ff"></div>しよう</div>
            <div class="card" onclick="sel('noda',this)"><div class="icon" style="background:#800080"></div>のだ</div>
        </div>
        <button onclick="goToStep2()" style="margin-top:20px;">次へ</button>
    </div>
    <div id="step2" class="box" style="display:none;">
        <h3>通信対戦</h3>
        <div style="border-bottom:1px solid #555; padding-bottom:15px; margin-bottom:15px;">
            <button onclick="createRoom()">IDを発行 (ホスト)</button>
            <div id="my-id-display" style="margin-top:10px; font-size:24px; color:#ffe600; user-select: text;"></div>
        </div>
        <div>
            <input type="text" id="dest-id" placeholder="相手のID">
            <button onclick="joinRoom()">接続 (ゲスト)</button>
        </div>
        <div id="status-msg" style="margin-top:10px; color:#0f0;"></div>
    </div>
</div>

<div id="result" class="overlay">
    <div id="win-msg">VICTORY!</div>
    <div class="rematch-status">
        <div id="st-p1" class="p-status">YOU</div>
        <div style="color:#fff;">vs</div>
        <div id="st-p2" class="p-status">OPPONENT</div>
    </div>
    <button id="rematch-btn" onclick="sendRematch()">キャラ選択へ戻る</button>
</div>

<div id="hud">
    <div class="hud-box">
        <div class="hud-name" id="p1n">YOU</div>
        <div class="pct" id="p1p">0%</div>
        <div class="bar-container" id="p1c_bar"><div class="bar-fill" id="p1c_fill" style="background:#ff0"></div></div>
        <div class="shield-bar"><div class="shield-fill" id="p1s_fill"></div></div>
        <div class="stocks" id="p1s"></div>
    </div>
    <div class="hud-box">
        <div class="hud-name" id="p2n">OPPONENT</div>
        <div class="pct" id="p2p">0%</div>
        <div class="bar-container" id="p2c_bar"><div class="bar-fill" id="p2c_fill" style="background:#ff0"></div></div>
        <div class="shield-bar"><div class="shield-fill" id="p2s_fill"></div></div>
        <div class="stocks" id="p2s"></div>
    </div>
</div>

<canvas id="cvs"></canvas>

<script>
// --- AUDIO SYSTEM ---
const AudioSys = {
    ctx: null,
    init: function() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
    },
    playTone: function(freq, type, dur, vol=0.1) {
        if(!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.start(); osc.stop(this.ctx.currentTime + dur);
    },
    playNoise: function(dur) {
        if(!this.ctx) return;
        const bufferSize = this.ctx.sampleRate * dur;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
        noise.connect(gain); gain.connect(this.ctx.destination);
        noise.start();
    },
    sfx: {
        jump: () => AudioSys.playTone(400, 'sine', 0.2),
        hit: () => { AudioSys.playNoise(0.1); AudioSys.playTone(150, 'sawtooth', 0.1, 0.2); },
        blast: () => { AudioSys.playNoise(0.5); AudioSys.playTone(50, 'square', 0.5, 0.3); },
        guard: () => AudioSys.playTone(800, 'square', 0.05, 0.05),
        shot: () => AudioSys.playTone(600, 'triangle', 0.1),
        win: () => { if(!AudioSys.ctx) return; [300, 400, 500, 600, 800].forEach((f, i) => setTimeout(() => AudioSys.playTone(f, 'sine', 0.4, 0.2), i*150)); }
    }
};

const cvs = document.getElementById('cvs');
const ctx = cvs.getContext('2d');
cvs.width = window.innerWidth; cvs.height = window.innerHeight;

const GRAVITY=0.5, STAGE_W=2400, GROUND_Y=250, BLAST={x:3200,y:2000};
const PLATFORMS=[{x:-600,y:0,w:300,h:20},{x:600,y:0,w:300,h:20},{x:0,y:-250,w:400,h:20}];
const CHARS={
    kou:{name:"こう",col:"#3399ff",type:"bal",speed:1.0,weight:1.0},
    minto:{name:"みんと",col:"#00ffcc",type:"rng",speed:1.1,weight:0.9},
    kanade:{name:"かなで",col:"#ff0066",type:"pow",speed:0.9,weight:1.2},
    shiyou:{name:"しよう",col:"#8888ff",type:"gun",speed:1.05,weight:1.0},
    noda:{name:"のだ",col:"#800080",type:"tnk",speed:0.7,weight:1.6}
};

let peer=null, conn=null, myId=null, isHost=false, gameRunning=false;
let myName="Player", oppName="Opponent", myChar='kou', oppChar='kou';
let p1=null, p2=null, projectiles=[], particles=[];
// ★ Fixed Camera
let cam={x:0,y:-100,z:0.65}; 
let rematchMe=false, rematchOpp=false;
const keys={};

window.onkeydown=e=>{ keys[e.key.toLowerCase()]=true; };
window.onkeyup=e=>{ keys[e.key.toLowerCase()]=false; };

function setName() { AudioSys.init(); const n = document.getElementById('username-input').value; if(n) myName=n; document.getElementById('step0').style.display='none'; document.getElementById('step1').style.display='block'; document.getElementById('welcome-msg').innerText="ようこそ、"+myName+"さん"; }
function sel(k,e) { myChar=k; document.querySelectorAll('.card').forEach(c=>c.classList.remove('selected')); e.classList.add('selected'); }
function goToStep2() { document.getElementById('step1').style.display='none'; document.getElementById('step2').style.display='block'; initPeer(); }

function initPeer() {
    if(peer) return;
    peer = new Peer();
    peer.on('open', id => myId = id);
    peer.on('connection', c => { conn = c; setupConn(); });
}
function createRoom() {
    if(!peer) initPeer();
    setTimeout(() => { document.getElementById('my-id-display').innerText=myId; document.getElementById('status-msg').innerText="待機中..."; isHost=true; }, 1000);
}
function joinRoom() {
    if(!peer) initPeer();
    setTimeout(() => { const id=document.getElementById('dest-id').value; if(!id)return alert("ID?"); conn = peer.connect(id); isHost=false; setupConn(); }, 500);
}
function setupConn() {
    document.getElementById('status-msg').innerText="接続成功！";
    conn.on('open', () => { 
        // Initial Handshake
        conn.send({ type:'init', name:myName }); 
    });
    conn.on('data', data => {
        if(data.type==='init') { 
            oppName=data.name; 
            // After connection, Go back to char select if needed, or start if both ready
            // Ideally: Stay connected, but allow char change.
            // Simplified: Just start logic.
            // For v16: We are at Step 2. We need to exchange CHARS now.
            // Let's just send 'ready' with char.
            conn.send({type:'ready', char:myChar});
        }
        if(data.type==='ready') {
            oppChar = data.char;
            startGame();
        }
        if(data.type==='sync') {
            let target = isHost ? p2 : p1;
            target.targetPos = data.pos; target.vel = data.vel; target.pct = data.pct; target.stocks = data.stocks;
            target.shieldHP = data.shp; target.charge = data.chg; target.act = data.act; target.faceR = data.fr;
            target.nodaPowered = data.np; target.shieldBroken = data.sb; target.anim = data.anim;
            if(data.fx) spawnFX(data.fx.x, data.fx.y, data.fx.type);
        }
        if(data.type==='hit') { 
            // I got hit (Receiver applies damage)
            let me = isHost ? p1 : p2; 
            me.applyHit(data.dmg, data.kb, data.dir, data.stun, true); 
        }
        if(data.type==='rematch_req') {
            rematchOpp = true; updateRematchUI();
            if(rematchMe && rematchOpp) returnToCharSelect();
        }
    });
    setInterval(sendSync, 33);
}
function sendSync() {
    if(conn && conn.open && gameRunning) {
        let me = isHost ? p1 : p2;
        conn.send({
            type:'sync', pos: me.pos, vel: me.vel, pct: me.pct, stocks: me.stocks, shp: me.shieldHP,
            chg: me.charge, act: me.act, fr: me.faceR, np: me.nodaPowered, sb: me.shieldBroken, anim: me.anim
        });
    }
}

function startGame() {
    document.getElementById('menu').style.display='none'; document.getElementById('result').style.display='none';
    document.getElementById('hud').style.display='flex'; cvs.style.display='block';
    p1 = new Fighter(true, isHost?myChar:oppChar, -300); p1.isMe = isHost; p1.displayName = isHost?myName:oppName;
    p2 = new Fighter(false, isHost?oppChar:myChar, 300); p2.isMe = !isHost; p2.displayName = isHost?oppName:myName;
    document.getElementById('p1n').innerText = p1.displayName; document.getElementById('p2n').innerText = p2.displayName;
    gameRunning=true; rematchMe=false; rematchOpp=false;
    document.getElementById('rematch-btn').disabled = false;
    document.getElementById('rematch-btn').innerText = "キャラ選択へ戻る";
    document.getElementById('st-p1').className = "p-status"; document.getElementById('st-p2').className = "p-status";
    AudioSys.sfx.win(); loop();
}

class Fighter {
    constructor(isP1, key, x) {
        this.isP1 = isP1; this.key = key; 
        this.col = CHARS[key].col; this.weight = CHARS[key].weight; this.speed = CHARS[key].speed;
        this.pos = {x:x, y:-300}; this.vel = {x:0, y:0}; this.targetPos = {x:x, y:-300};
        this.pct = 0; this.stocks = 3; this.faceR = isP1;
        this.act = 'IDLE'; this.actTime = 0; this.stun = 0; this.anim = 0;
        this.charge = 0; this.maxCharge = 120;
        this.shieldHP = 50; this.shieldMax = 50; this.shieldBroken = false; this.shieldBreakTimer = 0;
        this.canRecover = true; this.counterActive = false; this.ignorePlat = false;
        this.nodaPowered = false;
        this.prevJ = false; this.prevK = false;
    }

    update() {
        if(this.stocks <= 0) return;
        if(!this.isMe) {
            this.anim++;
            this.pos.x += (this.targetPos.x - this.pos.x) * 0.5; this.pos.y += (this.targetPos.y - this.pos.y) * 0.5;
            return; 
        }

        if(this.shieldBroken) { this.shieldBreakTimer--; if(this.shieldBreakTimer<=0){this.shieldBroken=false; this.shieldHP=50;} } 
        else if(this.act!=='GRD' && this.shieldHP<this.shieldMax) this.shieldHP+=0.05;

        if(this.stun>0){ this.stun--; this.phys(); return; }

        let inX=0, up=false, jmp=false, atk=false, smsh=false, grd=false, drop=false;
        let j_down=keys.j, j_press=keys.j && !this.prevJ; this.prevJ=keys.j;
        let k_press=keys.k && !this.prevK; this.prevK=keys.k;

        if(keys.a) inX=-1; if(keys.d) inX=1;
        if(keys.w) { up=true; jmp=true; }
        if(keys.s) { drop=true; }
        if(k_press) smsh=true;
        if(keys.z) grd=true;

        if(inX!==0) this.faceR = inX>0;
        this.ignorePlat = drop; if(drop && !this.onG) this.vel.y += 1.0;

        if (grd && this.onG && this.act !== 'ATK' && !this.shieldBroken) {
            this.act = 'GRD'; this.vel.x *= 0.5; this.counterActive = (this.key === 'kanade');
        } else {
            this.counterActive = false; if (this.act === 'GRD') this.act = 'IDLE';
        }

        if (this.actTime<=0 && up && j_press && !this.onG) {
             if(this.key==='noda') this.doRecovery(); 
             else if(this.canRecover) { this.doRecovery(); this.canRecover = false; }
             j_press = false;
        }

        const canCharge = (this.key==='minto'||this.key==='kanade');
        if (canCharge) {
            if (j_down && this.act!=='GRD' && this.actTime<=0) {
                this.charge=Math.min(this.charge+1, this.maxCharge);
                if(this.charge%20===0) AudioSys.playTone(200+(this.charge*2), 'sawtooth', 0.05);
                if(this.charge%10===0) spawnFX(this.pos.x, this.pos.y, this.key==='kanade'?'fire':'dust');
                atk=true;
            } else if (this.charge>0 && !j_down) {
                if(this.key==='minto') this.fireMintoShot(); if(this.key==='kanade') this.doKanadePunch();
                this.charge=0;
            }
        } else {
            if (j_press && this.actTime<=0 && this.act!=='GRD') atk=true;
        }

        if (this.actTime <= 0 && this.act !== 'GRD') {
            this.vel.x += inX * (this.onG?1.5:0.2) * this.speed;
            if (Math.abs(this.vel.x) > 0.5 && this.onG) this.act = 'RUN'; 
            else if(!this.onG) this.act = 'AIR'; else this.act = 'IDLE';

            if (jmp && this.jumps>0 && !this.prevJmp) {
                this.vel.y = -16; this.jumps--; this.onG=false; spawnFX(this.pos.x, this.pos.y+40, 'dust'); AudioSys.sfx.jump();
            }
            this.prevJmp = jmp;

            if (smsh) {
                if(this.key === 'shiyou') this.fireSniper(); else this.doSmash();
            } else if (atk) {
                if (!canCharge) {
                    if(this.key === 'shiyou') this.firePistol(); else this.doJab();
                }
            }
        } else { this.actTime--; }

        this.anim++; this.phys(); this.checkBlast(); this.updateHUD();
    }

    phys() {
        this.vel.y += GRAVITY; this.vel.x *= this.onG ? 0.8 : 0.98;
        this.pos.x += this.vel.x; this.pos.y += this.vel.y;
        this.onG = false; const footY = this.pos.y + 40;
        if(this.vel.y >= 0 && footY >= GROUND_Y && footY <= GROUND_Y + 40 && Math.abs(this.pos.x) < STAGE_W / 2) {
            this.vel.y = 0; this.pos.y = GROUND_Y - 40; this.onG = true; this.jumps = 2; this.canRecover = true;
        }
        if(!this.ignorePlat && this.vel.y >= 0) {
            for(let p of PLATFORMS) {
                if(this.pos.x > p.x - p.w/2 && this.pos.x < p.x + p.w/2 && footY >= p.y - p.h/2 && footY <= p.y + p.h/2 + 20) {
                    this.vel.y = 0; this.pos.y = p.y - p.h/2 - 40; this.onG = true; this.jumps = 2; this.canRecover = true;
                }
            }
        }
    }

    // Attacks (Modified Range/Damage)
    doRecovery() {
        this.act = 'ATK'; this.actTime = 30; this.vel.y = 0;
        if (this.key === 'kou') { this.vel.y = -14; spawnFX(this.pos.x, this.pos.y+30, 'gas'); this.createHitbox(0, 30, 60, 40, 1, 2, 10); }
        else if (this.key === 'minto') { this.vel.y = -15; projectiles.push(new Projectile(this, this.pos.x, this.pos.y+40, 0, 1, 'beam', 1.5, 10)); }
        else if (this.key === 'kanade') { this.vel.y = -22; spawnFX(this.pos.x, this.pos.y, 'fire'); this.createHitbox(0, 0, 40, 80, 3, 8, 30); }
        else if (this.key === 'shiyou') { this.vel.y = -12; this.actTime = 45; spawnFX(this.pos.x, this.pos.y-50, 'dust'); }
        else if (this.key === 'noda') {
            this.vel.y = -0.5; this.actTime = 25; spawnFX(this.pos.x, this.pos.y, 'dark');
            this.charge += 20; if(this.charge >= this.maxCharge) { this.charge = this.maxCharge; this.nodaPowered = true; spawnFX(this.pos.x, this.pos.y, 'dark', true); }
        }
        AudioSys.sfx.jump();
    }
    doJab() {
        this.act = 'ATK'; this.actTime = 20; let dmg=1.0, kb=2; 
        if(this.key === 'noda') { if(this.nodaPowered) { dmg=8; kb=20; this.nodaPowered=false; this.charge=0; spawnFX(this.pos.x, this.pos.y, 'dark', true); } else { dmg=2; kb=4; } }
        this.createHitbox(35, 0, 60, 40, dmg, kb, 10);
        AudioSys.playTone(300, 'square', 0.1);
    }
    doSmash() {
        this.act = 'ATK'; this.actTime = 50;
        setTimeout(()=>{
            if(this.stun>0)return; let dmg=3, kb=6, pwr=this.key==='kanade'?1.5:1.0, range=80;
            if(this.key === 'noda') {
                if(this.nodaPowered) { dmg=8; kb=25; pwr=1; this.nodaPowered=false; this.charge=0; spawnFX(this.pos.x, this.pos.y, 'dark', true); } else { dmg=4; kb=8; }
                this.createHitbox(0, 0, 150, 80, dmg, kb, 40); return;
            }
            this.createHitbox(40, -10, range, 50, dmg*pwr, kb*pwr, 40);
            AudioSys.playTone(200, 'sawtooth', 0.2);
        }, 150);
    }
    // Reduced Range for Minto/Shiyou
    fireMintoShot() { this.act = 'ATK'; this.actTime = 20; const dir=this.faceR?1:-1; const dmg=1+(this.charge/this.maxCharge)*4; const sz=10+(this.charge/this.maxCharge)*15; projectiles.push(new Projectile(this, this.pos.x+40*dir, this.pos.y, dir, 0, 'shot', dmg, sz, 30)); AudioSys.sfx.shot(); } // Life=30
    doKanadePunch() { this.act = 'ATK'; this.actTime = 40; const dmg=3+(this.charge/this.maxCharge)*5; const kb=8+(this.charge/this.maxCharge)*10; spawnFX(this.pos.x, this.pos.y, 'fire'); this.createHitbox(40, 0, 60, 60, dmg, kb, 40); AudioSys.sfx.shot(); }
    firePistol() { this.act = 'ATK'; this.actTime = 15; const dir=this.faceR?1:-1; projectiles.push(new Projectile(this, this.pos.x+40*dir, this.pos.y-10, dir*1.5, 0, 'shot', 0.8, 5, 20)); AudioSys.sfx.shot(); } // Life=20
    fireSniper() { this.act = 'ATK'; this.actTime = 80; setTimeout(() => { if(this.stun>0) return; const dir=this.faceR?1:-1; projectiles.push(new Projectile(this, this.pos.x+50*dir, this.pos.y-10, dir*3, 0, 'sniper', 5, 8, 60)); AudioSys.sfx.blast(); }, 40); } // Longer lag

    createHitbox(ox, oy, w, h, dmg, kb, stun) { const dir=this.faceR?1:-1; this.hitbox = { act:true, owner:this, x:this.pos.x+(ox*dir), y:this.pos.y+oy, w:w, h:h, dmg:dmg, kb:kb, stun:stun, dur:5, dir:dir }; }
    checkHit(hb) {
        // ★ Guard Fix: Receiver (Me) processes hit. If I am guarding, I block.
        if(!this.isMe) return; 
        
        // Guard Check
        if(this.act === 'GRD' && !this.shieldBroken) {
            if(this.key === 'kanade' && this.counterActive) { this.act = 'ATK'; this.actTime = 20; spawnFX(this.pos.x, this.pos.y, 'fire'); if(hb.owner) hb.owner.applyHit(5, 15, this.faceR?1:-1, 40, true); return; }
            this.shieldHP -= hb.dmg * 2;
            if (this.shieldHP <= 0) { this.shieldBroken = true; this.shieldBreakTimer = 600; this.stun = 120; spawnFX(this.pos.x, this.pos.y, 'expl'); } 
            else { this.pct += hb.dmg * 0.05; spawnFX(this.pos.x, this.pos.y, 'dust'); AudioSys.sfx.guard(); }
            return;
        }
        // Hit
        this.applyHit(hb.dmg, hb.kb, hb.dir, hb.stun, true);
    }
    applyHit(dmg, kb, dir, stun, forced) {
        // Forced allows network hit (but checkHit above handles logic)
        // If called directly via 'hit' event from opponent projectile, we trust it unless guarding
        if(!this.isMe && !forced) return;
        
        if(this.act === 'GRD' && !this.shieldBroken) {
             // Guard logic if called via network event
             this.shieldHP -= dmg * 2; AudioSys.sfx.guard();
             return;
        }

        this.pct += dmg; let kbVal = 0;
        if (this.pct < 100) kbVal = (kb * 0.1) / this.weight; else { let factor = (this.pct - 90) / 10; kbVal = (kb * factor) / this.weight; }
        this.vel.x = dir * kbVal * 2; this.vel.y = -kbVal * 1.5; this.stun = stun + kbVal; spawnFX(this.pos.x, this.pos.y, 'hit', kbVal>10);
        AudioSys.sfx.hit();
        this.updateHUD();
    }
    checkBlast() {
        if(!this.isMe) return;
        if(Math.abs(this.pos.x)>BLAST.x || Math.abs(this.pos.y)>BLAST.y) {
            this.stocks--; this.pct=0; this.pos={x:0,y:-400}; this.vel={x:0,y:0};
            this.shieldHP=50; this.shieldBroken=false; this.canRecover=true; this.nodaPowered=false; this.charge=0;
            spawnFX(this.pos.x, this.pos.y, 'expl'); AudioSys.sfx.blast();
            if(this.stocks<=0) showResult(false);
        }
    }
    updateHUD() {
        const id = this.isMe ? 'p1' : 'p2';
        document.getElementById(id+'p').innerText = Math.floor(this.pct)+"%";
        document.getElementById(id+'s_fill').style.width = (this.shieldHP/this.shieldMax)*100+"%";
        document.getElementById(id+'s_fill').style.background = this.shieldBroken ? "#555" : "#00aaff";
        let bar=document.getElementById(id+'c_bar'), fill=document.getElementById(id+'c_fill');
        if(this.key==='minto'||this.key==='kanade'||this.key==='noda') {
            bar.style.display='block'; fill.style.width = (this.charge/this.maxCharge)*100+"%";
            fill.style.background = (this.key==='kanade'||(this.key==='noda'&&this.nodaPowered))?'#f00':'#0ff';
        } else { bar.style.display='none'; }
        let sHtml=""; for(let i=0;i<this.stocks;i++) sHtml+=`<div class="dot" style="background:${this.col}"></div>`;
        document.getElementById(id+'s').innerHTML=sHtml;
    }
    draw() {
        if(this.stocks<=0) return;
        ctx.save(); ctx.translate(this.pos.x, this.pos.y); if(!this.faceR) ctx.scale(-1,1);
        ctx.save(); ctx.scale(this.faceR?1:-1, 1); ctx.fillStyle="white"; ctx.font="bold 16px Arial"; ctx.textAlign="center"; ctx.fillText(this.displayName, 0, -60); ctx.restore();
        const bob = this.onG ? Math.sin(this.anim*0.2)*2 : 0; ctx.translate(0, bob);
        let dC=this.col; if(this.key==='noda'&&this.nodaPowered&&Math.floor(this.anim/4)%2===0) dC="#ff00ff";
        let br=0, fr=0;
        if(this.act==='RUN'){const s=Math.sin(this.anim*0.4);br=s*0.8;fr=-s*0.8;} else if(this.act==='ATK'){fr=-1.5;br=0.5;if(this.key==='shiyou')fr=-1.6;if(this.key==='noda')fr=1.5;} else if(this.act==='GRD'){fr=-1.0;br=-1.0;}
        if(this.key==='shiyou'&&this.act==='ATK'&&this.vel.y<0){ctx.fillStyle='#444';ctx.fillRect(-20,-70,40,10);ctx.fillRect(-2,-70,4,30);ctx.fillStyle='#ccc';if(Math.floor(this.anim/2)%2===0){ctx.fillRect(-25,-75,15,2);ctx.fillRect(10,-75,15,2);}}
        ctx.save();ctx.translate(-5,-5);ctx.rotate(br);ctx.lineWidth=8;ctx.strokeStyle='#222';ctx.lineCap='round';ctx.beginPath();ctx.moveTo(0,0);ctx.lineTo(0,25);ctx.stroke();ctx.fillStyle=this.col;ctx.beginPath();ctx.arc(0,25,6,0,Math.PI*2);ctx.fill();ctx.restore();
        ctx.fillStyle=dC;ctx.beginPath();ctx.rect(-15,-15,30,45);ctx.fill();
        const lS=this.act==='RUN'?Math.sin(this.anim*0.4)*10:0; ctx.beginPath();ctx.moveTo(-5,30);ctx.lineTo(-8-lS,50);ctx.stroke();ctx.beginPath();ctx.moveTo(5,30);ctx.lineTo(8+lS,50);ctx.stroke();
        ctx.fillStyle='#ffe0bd';ctx.beginPath();ctx.arc(0,-25,18,0,Math.PI*2);ctx.fill(); ctx.fillStyle='#000'; if(this.shieldBroken)ctx.fillText("x x",-6,-25); else if(this.act==='GRD'){ctx.fillRect(-8,-28,5,2);ctx.fillRect(3,-28,5,2);}else{ctx.beginPath();ctx.arc(-6,-28,2,0,Math.PI*2);ctx.fill();ctx.beginPath();ctx.arc(6,-28,2,0,Math.PI*2);ctx.fill();}
        ctx.fillStyle=dC; if(this.key==='kou'){ctx.beginPath();ctx.moveTo(-20,-30);ctx.lineTo(0,-50);ctx.lineTo(20,-30);ctx.fill();}else if(this.key==='minto'){ctx.beginPath();ctx.arc(0,-30,20,Math.PI,0);ctx.lineTo(20,10);ctx.lineTo(-20,10);ctx.fill();}else if(this.key==='kanade'){ctx.beginPath();ctx.arc(0,-30,22,Math.PI,0);ctx.fill();}else if(this.key==='shiyou'){ctx.fillRect(-20,-45,40,15);ctx.fillRect(15,-30,5,30);}else if(this.key==='noda'){ctx.fillRect(-15,-50,30,25);ctx.fillRect(-5,-50,10,-10);}
        if(this.key==='kanade'&&this.counterActive){ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.beginPath();ctx.arc(0,0,40,0,Math.PI*2);ctx.stroke();}
        if(this.act==='GRD'&&!this.shieldBroken){ctx.fillStyle=`rgba(100,200,255,${this.shieldHP/100})`;ctx.beginPath();ctx.arc(0,0,40,0,Math.PI*2);ctx.fill();}
        ctx.save();ctx.translate(5,-5);ctx.rotate(fr);ctx.strokeStyle='#222';ctx.beginPath();ctx.moveTo(0,0);ctx.lineTo(0,25);ctx.stroke();
        if(this.key==='shiyou'){ctx.fillStyle='#444';if(this.act==='ATK'){ctx.fillRect(-5,20,25,6);ctx.fillRect(-5,20,6,10);}}
        if(this.key==='noda'){ctx.fillStyle='#ddd';ctx.fillRect(-5,10,30,6);ctx.fillStyle='#888';ctx.fillRect(-5,10,6,20);}
        let hC=this.col; if(this.charge>0){ctx.shadowBlur=10;ctx.shadowColor=this.key==='kanade'?'#f00':'#0ff';hC='#fff';} ctx.fillStyle=hC;ctx.beginPath();ctx.arc(0,25,6+(this.charge/10),0,Math.PI*2);ctx.fill();ctx.shadowBlur=0;ctx.restore();
        ctx.restore();
    }
}

class Projectile {
    constructor(o, x, y, dx, dy, type, dmg, sz, life) { this.o=o; this.x=x; this.y=y; this.vx=dx*15; this.vy=dy*15; this.type=type; this.dmg=dmg||1; this.sz=sz||5; this.life=life||60; }
    update() {
        this.x+=this.vx; this.y+=this.vy; this.life--; 
        let hb={x:this.x-this.sz, y:this.y-this.sz, w:this.sz*2, h:this.sz*2}; 
        if(this.o.isMe) {
            let target = this.o === p1 ? p2 : p1;
            if(isHit(hb, target)) {
                let kb=this.type==='sniper'?15:(this.type==='beam'?5:8);
                conn.send({type:'hit', dmg:this.dmg, kb:kb, dir:this.vx>0?1:-1, stun:20});
                this.life=0;
            }
        }
    }
    draw() { ctx.save(); ctx.translate(this.x, this.y); if(this.type==='beam') { ctx.fillStyle='#0ff'; ctx.fillRect(-5, -50, 10, 100); } else if(this.type==='sniper') { ctx.fillStyle='#ff0'; ctx.fillRect(-10, -2, 20, 4); } else { ctx.fillStyle=this.o.col; ctx.beginPath(); ctx.arc(0,0,this.sz,0,Math.PI*2); ctx.fill(); } ctx.restore(); }
}

function spawnFX(x, y, type) { let c='#fff'; if(type==='fire')c='#f00'; if(type==='gas')c='#0f0'; if(type==='dark')c='#a020f0'; for(let i=0;i<8;i++) particles.push({x:x, y:y, vx:(Math.random()-.5)*10, vy:(Math.random()-.5)*10, life:1.0, col:c}); }
function isHit(r1, t) { return (r1.x < t.pos.x+20 && r1.x+r1.w > t.pos.x-20 && r1.y < t.pos.y+40 && r1.y+r1.h > t.pos.y-40); }

function loop() {
    if(!gameRunning) return; requestAnimationFrame(loop);
    
    let me = isHost ? p1 : p2; let opp = isHost ? p2 : p1;
    me.update(opp); opp.anim++;
    opp.pos.x += (opp.targetPos.x - opp.pos.x) * 0.5; opp.pos.y += (opp.targetPos.y - opp.pos.y) * 0.5;
    opp.updateHUD();

    if(me.hitbox && me.hitbox.act) {
        if(isHit(me.hitbox, opp)) {
            let h = me.hitbox;
            conn.send({type:'hit', dmg:h.dmg, kb:h.kb, dir:h.dir, stun:h.stun});
            me.hitbox.act=false;
        }
        me.hitbox.dur--; if(me.hitbox.dur<=0) me.hitbox.act=false;
    }

    if(conn && conn.open) conn.send({ type:'sync', pos:me.pos, vel:me.vel, pct:me.pct, stocks:me.stocks, shp:me.shieldHP, chg:me.charge, act:me.act, fr:me.faceR, np:me.nodaPowered, sb:me.shieldBroken, anim:me.anim });

    ctx.fillStyle='#87CEEB'; ctx.fillRect(0,0,cvs.width,cvs.height);
    // Fixed Center Camera
    ctx.save(); ctx.translate(cvs.width/2, cvs.height/2); ctx.scale(cam.z, cam.z); ctx.translate(0, cam.y);
    ctx.fillStyle='#5d4037'; ctx.fillRect(-1200, 250, 2400, 500); ctx.fillStyle='#76ff03'; ctx.fillRect(-1200, 250, 2400, 20); ctx.fillStyle='#8d6e63'; PLATFORMS.forEach(p=>ctx.fillRect(p.x-p.w/2, p.y-p.h/2, p.w, p.h));
    p1.draw(); p2.draw();
    projectiles.forEach((p,i)=>{ p.update(); p.draw(); if(p.life<=0) projectiles.splice(i,1); });
    particles.forEach((p,i)=>{ p.x+=p.vx; p.y+=p.vy; p.life-=0.05; ctx.globalAlpha=p.life; ctx.fillStyle=p.col; ctx.beginPath(); ctx.arc(p.x,p.y,5,0,Math.PI*2); ctx.fill(); if(p.life<=0) particles.splice(i,1); });
    ctx.restore();
}

function showResult(win) {
    gameRunning = false;
    document.getElementById('result').style.display='flex';
    document.getElementById('hud').style.display='none';
    document.getElementById('win-msg').innerText = win ? "VICTORY!" : "DEFEAT...";
    document.getElementById('win-msg').style.color = win ? "#0f0" : "#f00";
    rematchMe = false; rematchOpp = false;
    document.getElementById('st-p1').className="p-status"; document.getElementById('st-p2').className="p-status";
    document.getElementById('rematch-btn').disabled = false; document.getElementById('rematch-btn').innerText = "キャラ選択へ戻る";
    AudioSys.sfx.win();
}
function sendRematch() {
    rematchMe = true;
    document.getElementById('rematch-btn').disabled = true; document.getElementById('rematch-btn').innerText = "待機中...";
    updateRematchUI(); conn.send({type:'rematch_req'});
    if(rematchMe && rematchOpp) returnToCharSelect();
}
function updateRematchUI() {
    const mySt = document.getElementById('st-p1'); const oppSt = document.getElementById('st-p2');
    if(rematchMe) { mySt.classList.add('ready'); mySt.innerText="YOU: READY"; }
    if(rematchOpp) { oppSt.classList.add('ready'); oppSt.innerText="OPP: READY"; }
}
function returnToCharSelect() {
    document.getElementById('result').style.display='none';
    document.getElementById('hud').style.display='none';
    document.getElementById('step1').style.display='block';
    document.getElementById('step2').style.display='none';
    document.getElementById('menu').style.display='flex';
    // Opponent will also trigger this via network 'rematch_req' check
}
</script>
</body>
</html>
